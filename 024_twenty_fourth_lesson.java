Несколько рекомендаций

Основная рекомендация -- аккуратнее продумывать систему типов в целом, применять весь потенциал ООП, 
его наиболее универсальные правила так, чтобы любое нарушение целостности в идеале контролировалось бы статически, на фазе компиляции. 
На практике в неоднозначных случаях также применяются паттерны проектирования, которые предлагают достаточно универсальные методы решения таких типовых проблем. 
Но эти методы, по сути, просто эвристики, а не строгие формализмы, и к сожалению, они обычно не имеют под собой хорошей теоретической основы.

Не спешите с родительскими абстракциями. 
Постепенно накапливайте список различных сущностей, которые явно подразумеваются в проекте, а формирование их предков, добавление нового уровня абстракции, откладывайте.

Главная проектная трудность при создании иерархии классов в нахождении подходящих абстракций. 
Делается это на основе АТД: каждый АТД должен специфицировать конкретную структуру данных со своим уникальным набором операций.
------------------------+++

Что такое абстрагирование?
Выделяется общий предок для уже существующего класса, который оказался частным случаем чего-то большего.
Проект начинался с конкретного класса, а потом стало ясно, что он не универсальный. Создаётся новый предок, а текущий класс становится потомком.
Например:
Изначально сделан класс ElectricCar, в котором есть:
 - метод charge(),
 - метод drive().
Но через время в проекте нужен бензиновый автомобиль.
Метод drive() остаётся, а charge() специфичен.
Если применять абстрагирование:
Можно создать родительский класс Car с методом drive().
ElectricCar становится потомком Car и добавляет charge().
 --- Поднимается один конкретный класс вверх ---
  
Что такое факторизация?
Несколько классов оказываются частными случаями одного более общего понятия, и для них выделяется общий родитель.
Это обобщение в сторону абстракции сразу для нескольких классов — создаётся новый родительский класс, чтобы убрать дублирование.
Например:
Уже есть классы:
Dog с методом bark() и eat();
Cat с методом meow() и eat();
Они оба умеют eat(), у них много общего: имя, возраст, кормление.
Можно применять факторизацию:
Создаём Animal, туда выносим общее: name, age, eat().
Dog и Cat становятся наследниками.
 --- Объединяем несколько классов в иерархию ---
