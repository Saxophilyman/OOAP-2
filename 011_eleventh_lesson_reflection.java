// Эталонный пример предполагает 
class General implements Serializable {
   ...
}

class Any extends General { }

...

final class None extends Any /*A, B, ....*/ { }

//

class Test {
    public static Any getSome() {
        return new None();
    }

    public static void setSome(Any any) {
        if (any instanceof None) {
            System.out.println("wrong value!!!");
        }
    }
}

/*
GPT повторяет и объясняет этот пример следующим образом:
None — это не реальный потомок всех прикладных классов, а символический.
То есть:
Все прикладные классы (например User, Vehicle, Product) наследуются от Any

None тоже наследуется от Any

А потому, везде, где ожидается Any, можно передать и None
[
 Это значит, что в метод, принимающий Any, ты можешь передать любой объект, который является подтипом Any.
 Потому что в Java: Объект подтипа можно присвоить переменной суперкласса (через полиморфизм)
]

Это даёт возможность использовать None как универсальную "пустую ссылку"

Прикладные классы "видят" None через Any

Ты можешь писать код, который принимает Any, а значит — может получить любой прикладной класс или None

Это работает как унифицированная "void-сущность", но в рамках системы типов
*/


//Возможно со временем это станет более понятным
